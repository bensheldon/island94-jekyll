---
title: "Reflections on GoodJob for Solid Queue"
date: 2023-10-10 09:05 PDT
published: true
tags: [GoodJob, Ruby]
---

<a href="/uploads/2023-10/rails_world_solid_queue.jpg"><img src="/uploads/2023-10/rails_world_solid_queue.jpg" alt="Rails World presents Solid Queue and Mission Control"></a>

_GoodJob, via its [introductory blog post](https://island94.org/2020/07/introducing-goodjob-1-0), was highlighted last week at Rails World. A new Active Job queue backend, [Solid Queue](https://rubygems.org/gems/solid_queue), was announced, and I'm excited to see where it goes!_

I attended Rails World in Amsterdam this past week. During the conference, a new Active Job backend was announced: Solid Queue ([video](https://www.youtube.com/watch?v=iqXjGiQ_D-A&t=3121s)), which has the potential to become first, first-party backend in Rails. Solid Queue, like my GoodJob, is backed by a relational database. I'm very excited about this! I had a chance to talk to Rosa Gutierrez, who is leading the effort at 37signals, and I'm hopeful that I'll be able to contribute to Solid Queue and who knows, maybe it could even become a successor to GoodJob.

With that thought in mind, I reflected on some of the design and motivations that became GoodJob, and that I believe are important regardless of the Active Job backend under development. These are not intended to be design documents but more a list of things that I have learned or come across during my 3 years working on GoodJob. It would be nice to keep these in mind when designing a potential successor to GoodJob. And I hope they can be the seed to further conversations, rather than a fully realized proposal or argument. Let's go:

- **SIGKILL Safety**. Recovering from a SIGKILL (or someone unplugging the power cord) is always number one in my mind when thinking of GoodJob. That informed my desire to use Advisory Locks (which are automatically released on disconnect), and my future thinking about heartbeats if GoodJob switched over to using `FOR UPDATE SKIP LOCK` instead of Advisory Locks. I do not think jobs should be limited to a specific timeout (as Delayed Job's design uses) as that also creates significant retry latency when resumed, and jobs definitely shouldn't be wrapped with a transaction either.
- **(Human) Exception and Retry Workflows**. Everybody has a different workflow for how they deal with errors, and I believe that a backend needs to track, report (e.g. send to Sentry or Bugsnag) and expose the various reasons an error appears: retried, retry stopped, explicitly discarded, SIGKILLed/interrupted, unhandled error, etc. I still am dialing this in on GoodJob because there is wide variability of how people and teams manage their error workflows. I'm always learning something new. For example, there are very different answers on "when using `retry_on SpecialError, attempts: 3` should the 4th error be reported to the exception tracker? What about an explicit `discard_on`? Should a `discard_on` error be reviewed and reenqueued or not?" If a job is SIGKILLed/interrupted, should it be automatically restarted or held for manual review? Everyone seems to do it differently! I haven't cracked the code on what is "ideal" or reasonable to say "nope, don't do it _that_ way." Active Job's error handling isn't clear cut either, so maybe we can make that better and come around to a more opinionated (but still inclusive) design. Maybe!
- **Process Harnesses**. I think it's interesting that Rails might ship with a 1st party queue backend before it ships with a 1st party webserver: there is a lot of operational overlap. Signal handling, timeouts, daemonization, liveness and healthcheck probes, monitoring and scaling instrumentation. There's quite a lot of ground to cover, and a lot different systems and tooling: Kubernetes,  systemd, rc.d, Heroku, Judoscale, to name just a few of the various operational targets that I've spent considerable time supporting.
- **Repeating Jobs / Clock Process**. It took me [a while to come around to this](https://github.com/bensheldon/good_job/issues/255) in GoodJob, but I believe that performing work _repetitively on a schedule_ ("cron-like") is very much in the same problem-domain as background jobs. There's lots of different ways to design it that I don't feel strongly about, for example GoodJob minimizes autoloading by keeping schedules separate from job classes, but I do think it is necessary to plan for scheduled jobs in a well-architected Rails application.
- **Unique Jobs, Throttles, Fuses and other Concurrency Controls**,. Similarly to Repeating Jobs, demand is high for everything I'd bucket under "concurrency controls", which I'll say covers both enqueue and dequeue complexity. And these features are tough because they sit in counterbalance to overall performance: do you want to run jobs faster or smarter? And these are the features that I think are legit because there are other features below under Queue Design that I think are bunk. There's a lot of discernment to do!
- **Queue design and multi-queue execution pools**. I do think queue design is a place where lots of people do it wrong. I believe queues should be organized by maximum total latency SLO (`latency_15s`, `latency_15m` , `latency_8h`) and _not_ by their purpose or dependencies  (`mailers`, `billing`, `api`). [Nate Berkopec believes similarly.](https://www.railsspeed.com/) And I think that informs that **execution pools (e.g. thread pools) should be able to work from multiple queues and have independent concurrency configuration (e.g. number of threads)**, both to ease transition from the latter to the former, but also because it allows sharing resources as optimally as possible (having 3 separate pools that pull from `"latency_15s"`, `"latency_15m, latency_15s"`, and `"latency_8h,*"` in GoodJob's syntax). I personally think concepts like priority or ordered-queues lead to bad queue design, so I wouldn't sweat that. Any ordering regime more complex than first-in-first-out (FIFO) prioritizes capacity (or lack thereof) over latency. This might sound strange coming from me who champions running workloads in the webbrowser on tiny dynos, but it's different in my mind: I don't think it's possible to meet a latency target through prioritization when there is a fundamental lack of capacity.
- **Labels**. Per the previous point, though I have yet to implement this in GoodJob (soon!), I think that giving developers the option to label their jobs might break their bad habit of using queue names as functional labels, instead of what I believe queues should be appropriately used for: latency and quality-of-service thresholds. I mention it here just in case that informs Solid Queue's design.
- **Observability**. GoodJob maintains a lot of bookkeeping, keeping job and granular execution data around after execution so it can be inspected. People seem to like that, and it's necessary to keep them around for calculating accurate latency metrics, though it all is a trade-off against performance. It makes for a fun Web Dashboard too.
- **Performance Envelope.** I dunno, I mention this just because I think people spend an inordinate amount of time comparing queue backend performance and asking "do the jobs go brrrrr?" GoodJob targets the small and medium end of projects (though some big ones use it too) and prioritizes operational simplicity over performance. That works for me (and a lot of others!) but also isn't really reflective of the scale of companies leading Rails development. There's a tension here.
- **Making better mistakes tomorrow**. I'm really proud of having a reputation for being helpful and responsive and curious in the GoodJob issue queue and discussions and various support Slacks (like [Rails Link](https://www.rubyonrails.link)). I think there is a lot to the queue backend domain that won't be learned by upfront analysis, and that can't be easily bucketed into either "the library is doing it wrong" or "the developer is doing it wrong" There's a lot of variation! (not to mention across JRuby,etc. and various database versions). I'm able to do things with GoodJob that I think is unlikely on a 1st party Rails queue backend (like cutting a new release after every patch and fix), and I'm able to stay oriented to the people and the problem they're trying to solve over the technological solution itself. I hope all that can be preserved as these things move upstream.

That's it! I'm probably forgetting stuff, so I'll reserve the right to keep adding to this list. I'd love to keep talking about this and hope that Solid Queue will be fantastic!

_Oh, and Solid Queue isn't released yet, so if this seems compelling, [use GoodJob](https://github.com/bensheldon/good_job) in the meantime._
